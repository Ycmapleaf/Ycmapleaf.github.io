[{"categories":["MEETING"],"content":"时间：2024年11月7日——2024年12月1日 地点：中国·重庆 地址：重庆雾都宾馆（重庆市渝中区曾家岩24号） 举办单位：中国科学院计算技术研究所 协办单位：中国计算机协会高性能计算专委会 承办单位：中国计算技术西部研究所 会议主题： AI4Science及科学应用。 国产超算上的应用移植和优化。 机器学习系统。 混合精度计算方法。 数据压缩。 ","date":"2024-11-19","objectID":"/the_2nd_high_performance_computing_youth_forum_workshop/:0:0","tags":["HPC"],"title":"The_2nd_High_Performance_Computing_Youth_Forum_Workshop","uri":"/the_2nd_high_performance_computing_youth_forum_workshop/"},{"categories":["MEETING"],"content":"会议议程 日期 安排 时间 11/27 签到 11/28 会议Day1 8:20-11:50 13:00-17:35 17:35-18:30 18:30-20:30 11/29 会议Day2 8:20-11:50 13:00-17:35 11/30 会议Day3 12/01 会议Day4 ","date":"2024-11-19","objectID":"/the_2nd_high_performance_computing_youth_forum_workshop/:1:0","tags":["HPC"],"title":"The_2nd_High_Performance_Computing_Youth_Forum_Workshop","uri":"/the_2nd_high_performance_computing_youth_forum_workshop/"},{"categories":["MEETING"],"content":"会议报告 时间/Time 报告题目/Title 报告人/Speaker 单位/Affiliation 备注 11月28日上午 8:20-8:30 会议情况介绍+致辞/Introduction and Greeting 谭光明 8:30-8:55 Pushing the Limit of Quantum Mechanical Simulation to the Raman Spectra of a Biological System with 100 Million Atoms 推动量子力学模拟极限至具有1亿原子的生物系统的拉曼光谱 商红慧 中国科学技术大学 8:55-9:20 A Performance-Portable Kilometer-Scale Global Ocean Model Across Various Architecture Systems 跨不同体系结构的高性能便携式公里级全球海洋模型 韦健 中国科学院计算机网络信息中心 9:20-9:45 A High-Quality Workflow for Multi-Resolution Scientific Data Reduction and Visualization 多分辨率科学数据降维与可视化的高质量工作流 刘泽辉 中国科学院计算技术研究所 9:45-10:10 Moiræ: Generating High-Performance Composite Stencil Programs with Global Optimizations Moiræ：通过全局优化生成高性能复合模板程序 刘笑明 北京航空航天大学 1.内存分析 2.模板化 3.高性能代码生成 10:10-10:35 Towards Highly Compatible IO-aware Workload Scheduling on HPC Systems 面向高性能计算系统的高度兼容IO感知工作负载调度 戴俊政 国防科技大学 1.工作流调度 10:35-11:00 MCFuser: High-performance and Rapid-fail of Memory-bound Compute-intensive Operators MCFuser：内存受限的计算密集型算子高性能和快速融合 张帆 武汉大学 1.算子融合 11:00-11:25 Boosting DA Center Performance via Intelligently Managed Multi-backed Disaggregated Memory 通过智能管理的多后端分解内存提升数据中心性能 王靖 上海交通大学 1.内存配制 11:25-11:50 SMless Serving DAG-based Inference with Dynamic Invocations under Serverless Computing SMIless：在无服务器计算条件下通过动态调用为基于 DAG 的推理提供服务 卢浩远 中国科学院深圳先进技术研究院 11月28日下午 13:00-13:25 Scaling Molecular Dynamics with ab initio Accuracy to 149 Nanoseconds per Day 将分子动力学的从头算精度扩展到每天149纳秒 李剑锋 中国科学院计算技术研究所 13:25-13:50 A Conflict-aware Divide-and-Conquer Algorithm for Symmetric Sparse Matrix-Vector Multiplication 面向对称稀疏矩阵-向量乘法的冲突感知分治算法 邱奥中 国防科技大学 13:50-14:15 Accelerating Distributed DLRM Training with Optimized TT Decomposition and Micro-Batching 通过优化TT分解和微批处理加速分布式DLRM训练 王威威 武汉大学 14:15-14:40 Scaling New Heights: Transformative Cross-GPU Sampling for Training Billion-Edge Graphs 达到新高度：用于训练十亿边图的变革性跨GPU采样 夏亚东 武汉大学 14:40-15:05 AmgX: Algebraic Multigrid Solver on Many Cores AmgX：多核上的代数多重网格求解器 曾礼杰 中国石油大学(北京) 15:05-15:30 LoRaStendil: Low-Rank Adaptation of Stencil Computation on Tensor Cores LoRaStendil：张量核上的模板计算低秩适应 张祥胜 中国科学院计算技术研究所 15:30-15:55 GVARP: Detecting Performance Variance on Large-Scale Heterogeneous System GVARP：在大规模异构系统上检测性能差异 游心 北京航空航天大学 15:55-16:20 Mille-feuille: A Tile-grained Mixed-Precision Single-Kernel GPU Gradient Solver on CPUs Mlle-feuille：CPU 上的分层混合精度单核 GPU 梯度求解器 杨逸翔 中国石油大学(北京) 1.混精 16:20-16:45 DBSSR: An Efficient Storage Format for Vectorizing Sparse Triangular Solvers on Structured Grids DBSSR：在结构化网格上向量化稀疏三角求解器的高效存储格式 杨南剑 国防科技大学 16:45-17:10 Enabling 1K-atom Stencil-based ON Calculations via Low-rank Approximations and High-performance Computing on leadership supercomputers 通过低秩近似和领导级超级计算机上的高性能计算实现1K原子模板基础的ON计算 吴文斌 中国科学技术大学 17:10-17:35 MIXQ: Taming Dynamic Outliers in Mixed-Precision Quantization by Online Prediction MIXQ：通过在线预测驯服混合精度量化中的动态异常值 陈逸东 清华大学 1.混精 17:35-18:30 Poster section 18:30-20:30 Reception 11月29日上午 8:30-8:55 MIXQ: Taming Dynamic Outliers in Mixed-Precision Quantization by Online Prediction MIXQ：通过在线预测驯服混合精度量化中的动态异常值 陈逸东 清华大学 1.混精 8:55-9:20 Long Sequences: Accelerating Parameter-Efficient Fine-Tuning for LLMs under Shadowy Sparsity 长序列：在阴影稀疏性下加速大型语言模型的参数高效微调 王拓为 清华大学 9:20-9:45 Exploring Efficient Partial Differential Equation Solution using Speed Galerkin Transformer 探索使用Speed Galerkin Transformer求解高效偏微分方程 朱英浩 中国石油大学（华东） 9:45-10:10 Unlocking High-Performance with Low-Bit NPUs and CPUs for Highly Optimized HPLMKP on Cloud Brain II 解锁高性能：在云脑II上使用低比特NPU和CPU优化的HPLMKP 薛伟诚 鹏城实验室 10:10-10:35 APTMoE: Affinity-aware Pipeline Tuning for MoE Models on Bandwidth-constrained GPU Nodes APTMoE：在带宽受限的GPU节点上为MoE模型进行亲和感知的流水线调优 韦媛媛 中山大学 10:35-11:00 Enumeration of Billions of Maximal Biclique in Bipartite Graphs without Using GPUs 在不使用GPU的情况下枚举二分图中的数十亿最大双团 潘哲 浙江大学 11:00-11:25 UMR: Unified Notifiable RMA Library for HPC UMR：面向高性能计算的统一可通知远程内存访问库 丰光南 中山大学 11:25-11:50 EXO: Accelerating Storage Paravirtualization with eBPF EXO：使用eBPF加速存储虚拟化 仇奕 厦门大学 11月29日下午 13:00-13:25 Hydrogen: Contention-Aware Hybrid Memory for Hete","date":"2024-11-19","objectID":"/the_2nd_high_performance_computing_youth_forum_workshop/:2:0","tags":["HPC"],"title":"The_2nd_High_Performance_Computing_Youth_Forum_Workshop","uri":"/the_2nd_high_performance_computing_youth_forum_workshop/"},{"categories":["LLVM"],"content":"DFA 确定有限状态自动机 - 维基百科，自由的百科全书 DFA（deterministic finite automaton，确定有限状态自动机或确定有限自动机），一个能实现状态转移的自动机。对于一个给定的属于该自动机的状态和一个属于该自动机字母表的字符，它都能根据事先给定的转移函数转移到下一个状态（这个状态可以是先前那个状态）。 ","date":"2024-09-03","objectID":"/vliw_packetizer/:1:0","tags":["note","llvm-backend"],"title":"VLIW Packetizer","uri":"/vliw_packetizer/"},{"categories":["LLVM"],"content":"DFAPacketizer llvm/include/llvm/CodeGen/DFAPacketizer.h llvm/lib/CodeGen/DFAPacketizer.cpp DFAPacketizer 一个确定性有限自动机（DFA）由三个主要元素组成：状态（states）、输入（inputs）和转换（transitions）。对于打包机制来说，输入是目标指令类集合。状态模拟了在给定指令包中所有可能的功能单元消耗组合。转换模拟了将指令添加到指令包中的过程。在这个类构建的确定性有限自动机中，如果一个指令可以被添加到指令包中，那么就存在一个有效的从相应状态出发的转换。无效的转换表明该指令不能被添加到当前的指令包中。 ","date":"2024-09-03","objectID":"/vliw_packetizer/:2:0","tags":["note","llvm-backend"],"title":"VLIW Packetizer","uri":"/vliw_packetizer/"},{"categories":["LLVM"],"content":"VLIWPacketizer 位于Post-RA之后，MC生成之前 调度边界：主要包括标签和终止符。 ","date":"2024-09-03","objectID":"/vliw_packetizer/:3:0","tags":["note","llvm-backend"],"title":"VLIW Packetizer","uri":"/vliw_packetizer/"},{"categories":["LLVM"],"content":"相关文件 llvm/lib/CodeGen/DFAPacketizer.cpp llvm/include/llvm/CodeGen/DFAPacketizer.h llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h llvm/lib/CodeGen/ScheduleDAGInstrs.cpp ","date":"2024-09-03","objectID":"/vliw_packetizer/:3:1","tags":["note","llvm-backend"],"title":"VLIW Packetizer","uri":"/vliw_packetizer/"},{"categories":["LLVM"],"content":"相关名词 AAResults：Alias Analysis（别名分析） SU：Scheduling unit，scheduling DAG上的节点 ","date":"2024-09-03","objectID":"/vliw_packetizer/:3:2","tags":["note","llvm-backend"],"title":"VLIW Packetizer","uri":"/vliw_packetizer/"},{"categories":["LLVM"],"content":"预处理 主要思想：去除基本块冗余部分，确定打包范围 在打包前添加mutation。 删除Kill伪指令。 从基本块开始位置，找到第一个非调度边界RB。 从3处位置开始，找到第一条调度边界RE。 如果RE不为End，则自增 如果RB不为End，根据打包策略对RB到RE内所有指令进行打包 ","date":"2024-09-03","objectID":"/vliw_packetizer/:3:3","tags":["note","llvm-backend"],"title":"VLIW Packetizer","uri":"/vliw_packetizer/"},{"categories":["LLVM"],"content":"打包 生成inc tablegen(LLVM MT3000GenDFAPacketizer.inc -gen-dfa-packetizer) automaton 一个确定性有限状态自动机。该自动机在 TableGen 中定义；这个对象驱动由 tblgen 产生的表格定义的自动机。 自动机接受一系列输入标记（“动作”）。这个类是根据这些动作的类型来模板化的。 VLIWPacketizerList 构造 创建ResourceTracker ResourceTracker = TII-\u003eCreateTargetScheduleState(MF.getSubtarget()); 目标后端需要覆盖CreateTargetScheduleState接口： 该接口位于llvm/include/llvm/CodeGen/TargetInstrInfo.h。 在目标后端的xxxInstrInfo中覆盖。 该接口调用生成inc生成的createDFAPacketizer函数 设定Transcribe 该属性确定是否打包器应该追踪指令和功能单元，false为只追踪指令 ResourceTracker-\u003esetTrackResources(true); A.enableTranscription(Track); Transcribe = Enable; 创建VLIW调度器 VLIWScheduler = new DefaultVLIWScheduler(MF, mli, AA); 该调度器会创建相关依赖图。 ResourceTracker getUsedResources clearResources canReserveResources VLIWScheduler 打包MI VLIWScheduler准备 确定开始基本块 初始化DAG和调度器状态 构建调度图 MI映射 将MI映射到SU上 初始化打包器状态 initPacketizerState 需要在xxxPacketizer中覆盖 单独打包指令 isSoloInstruction 不需要打包的指令 ignorePseudoInstruction ","date":"2024-09-03","objectID":"/vliw_packetizer/:3:4","tags":["note","llvm-backend"],"title":"VLIW Packetizer","uri":"/vliw_packetizer/"},{"categories":["LLVM"],"content":"解包 由于DFAPacketizer不提供解包接口，所以需要为相关目标提供解包功能。 实现解包接口unpacketizeSoloInstrs。 ","date":"2024-09-03","objectID":"/vliw_packetizer/:3:5","tags":["note","llvm-backend"],"title":"VLIW Packetizer","uri":"/vliw_packetizer/"},{"categories":["LLVM"],"content":"可视化 VLIWScheduler最终继承了llvm/include/llvm/CodeGen/ScheduleDAG.h的ScheduleDAG类 llvm/lib/CodeGen/ScheduleDAGPrinter.cpp包含ScheduleDAG::viewGraph方法 llvm/lib/CodeGen/MachineScheduler.cpp包含ScheduleDAGMI::viewGraph方法 llvm/lib/CodeGen/SelectionDAG/SelectionDAGPrinter.cpp包含SelectionDAG::viewGraph方法 ","date":"2024-09-03","objectID":"/vliw_packetizer/:3:6","tags":["note","llvm-backend"],"title":"VLIW Packetizer","uri":"/vliw_packetizer/"},{"categories":["LLVM"],"content":"HazardRecognizer 目标后端的实现会在llvm/lib/CodeGen/PostRAHazardRecognizer.cpp中使用 ","date":"2024-09-03","objectID":"/vliw_packetizer/:3:7","tags":["note","llvm-backend"],"title":"VLIW Packetizer","uri":"/vliw_packetizer/"},{"categories":["LLVM"],"content":"Others llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp是对pre-RA的调度 llvm/lib/CodeGen/MachineScheduler.cpp是对machine的调度 ","date":"2024-09-03","objectID":"/vliw_packetizer/:3:8","tags":["note","llvm-backend"],"title":"VLIW Packetizer","uri":"/vliw_packetizer/"},{"categories":["LLVM"],"content":"本文章为LLVM DFAPacketizer的源码分析。 相关文件路径 llvm/include/llvm/CodeGen/DFAPacketizer.h llvm/lib/CodeGen/DFAPacketizer.cpp 一个确定性有限自动机（DFA）由三个主要元素组成：状态（states）、输入（inputs）和转换（transitions）。对于打包机制来说，输入是目标指令类集合。状态模拟了在给定指令包中所有可能的功能单元消耗组合。转换模拟了将指令添加到指令包中的过程。在这个类构建的确定性有限自动机中，如果一个指令可以被添加到指令包中，那么就存在一个有效的从相应状态出发的转换。无效的转换表明该指令不能被添加到当前的指令包中。 DFAPacketizer定义三个类DefaultVLIWScheduler、DFAPacketizer、VLIWPacketizerList。 ","date":"2024-09-03","objectID":"/dfa_packetizer/:0:0","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"DefaultVLIWScheduler 构建依赖图。 ","date":"2024-09-03","objectID":"/dfa_packetizer/:1:0","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"类定义 // 这个类扩展了 ScheduleDAGInstrs，并覆盖了 schedule 方法以构建依赖图。 class DefaultVLIWScheduler : public ScheduleDAGInstrs { private: AAResults *AA; // DAG 后处理步骤的有序列表。 std::vector\u003cstd::unique_ptr\u003cScheduleDAGMutation\u003e\u003e Mutations; public: DefaultVLIWScheduler(MachineFunction \u0026MF, MachineLoopInfo \u0026MLI, AAResults *AA); // 调度。 void schedule() override; // DefaultVLIWScheduler拥有突变对象的所有权。 void addMutation(std::unique_ptr\u003cScheduleDAGMutation\u003e Mutation) { Mutations.push_back(std::move(Mutation)); } protected: void postProcessDAG(); }; ","date":"2024-09-03","objectID":"/dfa_packetizer/:1:1","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"变量 AA 别名分析。 AAResults *AA Mutations 存储DAG后处理阶段的有序列表。 std::vector\u003cstd::unique_ptr\u003cScheduleDAGMutation\u003e\u003e Mutations ScheduleDAGMutation在DAG构建后为针对调度的依赖图的目标特定变异（llvm/include/llvm/CodeGen/ScheduleDAGMutation.h）。 ","date":"2024-09-03","objectID":"/dfa_packetizer/:1:2","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"目标无关函数 DefaultVLIWScheduler 构造函数。 schedule 调度工作。 void DefaultVLIWScheduler::schedule() { // 构建调度图 // llvm/lib/CodeGen/ScheduleDAGInstrs.cpp buildSchedGraph(AA); postProcessDAG(); } addMutation 添加异变对象。 postProcessDAG DAG后处理。 ","date":"2024-09-03","objectID":"/dfa_packetizer/:1:3","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"DFAPacketizer 该类进行资源管理以及自动机操作。 ","date":"2024-09-03","objectID":"/dfa_packetizer/:2:0","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"类定义 class DFAPacketizer { private: const InstrItineraryData *InstrItins; // 自动机 Automaton\u003cuint64_t\u003e A; // 对于每条调度，都有一个应用于自动机的“行为”。这消除了行程类别之间动作的冗余。 ArrayRef\u003cunsigned\u003e ItinActions; public: DFAPacketizer(const InstrItineraryData *InstrItins, Automaton\u003cuint64_t\u003e a, ArrayRef\u003cunsigned\u003e ItinActions) : InstrItins(InstrItins), A(std::move(a)), ItinActions(ItinActions) { // 开始时禁用资源跟踪功能。 A.enableTranscription(false); } // 重置当前状态，另所有资源可获取 void clearResources() { A.reset(); } // 设置这个打包器是否不仅应该跟踪指令是否可以打包， // 而且还要跟踪在打包之后每条指令最终使用哪些功能单元。 void setTrackResources(bool Track) { A.enableTranscription(Track); } // 检查当前状态下MCInstrDesc占用的资源是否可用。 bool canReserveResources(const MCInstrDesc *MID); // 预留MCInstrDesc占用的资源，并改变当前状态以反映这一变化。 void reserveResources(const MCInstrDesc *MID); // 检查机器指令占用的资源在当前状态下是否可用。 bool canReserveResources(MachineInstr \u0026MI); // 预留机器指令占用的资源，并更新当前状态以反映这一变化。 void reserveResources(MachineInstr \u0026MI); // 返回添加到这个数据包中的第InstIdx条指令所使用的资源。 // 资源以功能单元的位向量形式返回。 // 注意，一个指令束可能有多种有效的打包方式。这个函数返回一种任意有效的打包。 // 需要先调用setTrackResources(true)。 unsigned getUsedResources(unsigned InstIdx); // 获取子目标提供的供目标使用的调度数据。 const InstrItineraryData *getInstrItins() const { return InstrItins; } }; ","date":"2024-09-03","objectID":"/dfa_packetizer/:2:1","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"变量 InstrItins 调度数据。 const InstrItineraryData *InstrItins A 自动机。 Automaton\u003cuint64_t\u003e A ItinActions 调度行为。 ArrayRef\u003cunsigned\u003e ItinActions ","date":"2024-09-03","objectID":"/dfa_packetizer/:2:2","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"目标无关函数 DFAPacketizer 构造函数。 开启自动机A的转录功能（Transcription）。 clearResources 重置自动机A，使所有资源可获取。 setTrackResources 根据Track设置自动机A是否转录，表示除考虑打包外还应考虑功能单元的应用。 canReserveResources 1.canReserveResources(const MCInstrDesc *MID): 检查被一个MCInstrDesc占用的资源是否可获取。 bool DFAPacketizer::canReserveResources(const MCInstrDesc *MID) { unsigned Action = ItinActions[MID-\u003egetSchedClass()]; if (MID-\u003egetSchedClass() == 0 || Action == 0) return false; return A.canAdd(Action); } // llvm/include/llvm/Support/Automaton.h bool canAdd(const ActionT \u0026A) { auto I = M-\u003efind({State, A}); return I != M-\u003eend(); } 根据MID获取调度类别。 根据调度类别获取调度行为。 如果没有调度类别或调度行为，结束。 否则使用自动机A确定调度行为是否可以被转换。 getSchedClass获取该指令的调度类别，其结果为InstrItineraryData表的索引。 2.canReserveResources(MachineInstr \u0026MI): 检查MachineInstr占用的资源在当前状态下是否可用。 该方法调用canReserveResources(const MCInstrDesc *MID)。 reserveResources 1.reserveResources(const MCInstrDesc *MID): 预留MCInstrDesc占用的资源，并改变当前状态以反映这一变化。 void DFAPacketizer::reserveResources(const MCInstrDesc *MID) { unsigned Action = ItinActions[MID-\u003egetSchedClass()]; if (MID-\u003egetSchedClass() == 0 || Action == 0) return; A.add(Action); } // llvm/include/llvm/Support/Automaton.h bool add(const ActionT \u0026A) { auto I = M-\u003efind({State, A}); if (I == M-\u003eend()) return false; if (Transcriber \u0026\u0026 Transcribe) Transcriber-\u003etransition(I-\u003esecond.second); State = I-\u003esecond.first; return true; } 根据MID获取调度类别。 根据调度类别获取调度行为。 如果没有调度类别或调度行为，结束。 否则将该行为添加到自动机A中。 2.reserveResources(MachineInstr \u0026MI): 预留MachineInstr占用的资源，并更新当前状态以反映这一变化。 该方法调用reserveResources(const MCInstrDesc *MID)。 getUsedResources 返回添加到这个数据包中的第InstIdx条指令所使用的资源，资源以功能单元的位向量形式返回。注意，一个指令束可能有多种有效的打包方式。这个函数返回一种任意有效的打包。需要先调用setTrackResources(true)。 unsigned DFAPacketizer::getUsedResources(unsigned InstIdx) { ArrayRef\u003cNfaPath\u003e NfaPaths = A.getNfaPaths(); assert(!NfaPaths.empty() \u0026\u0026 \"Invalid bundle!\"); const NfaPath \u0026RS = NfaPaths.front(); // RS stores the cumulative resources used up to and including the I'th // instruction. The 0th instruction is the base case. if (InstIdx == 0) return RS[0]; // Return the difference between the cumulative resources used by InstIdx and // its predecessor. return RS[InstIdx] ^ RS[InstIdx - 1]; } getInstrItins 获取子目标提供的供目标使用的调度数据 ","date":"2024-09-03","objectID":"/dfa_packetizer/:2:3","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"VLIWPacketizerList VLIWPacketizerList 实现了一个使用 DFA（确定性有限自动机）的简单 VLIW 指令打包器。该打包器在机器基本块上工作。对于 BB（基本块）中的每条指令 I，打包器会查询 DFA 来看是否有足够的机器资源来执行 I。如果是这样，打包器会检查 I 是否依赖当前数据包中的任何指令。如果没有发现依赖关系，I 就会被添加到当前数据包中，并且相应的机器资源会被标记为已占用。如果发现了依赖关系，就会进行目标 API 调用以剪枝依赖。 ","date":"2024-09-03","objectID":"/dfa_packetizer/:3:0","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"类定义 class VLIWPacketizerList { protected: MachineFunction \u0026MF; const TargetInstrInfo *TII; AAResults *AA; // VLIW调度器 DefaultVLIWScheduler *VLIWScheduler; // 当前数据包包含的指令。 std::vector\u003cMachineInstr*\u003e CurrentPacketMIs; // DFA资源追踪器。 DFAPacketizer *ResourceTracker; // 指令到功能单元的映射。 std::map\u003cMachineInstr*, SUnit*\u003e MIToSUnit; public: // 构造函数，AAResults参数可以为空指针。 VLIWPacketizerList(MachineFunction \u0026MF, MachineLoopInfo \u0026MLI, AAResults *AA); virtual ~VLIWPacketizerList(); // 指令打包接口。 void PacketizeMIs(MachineBasicBlock *MBB, MachineBasicBlock::iterator BeginItr, MachineBasicBlock::iterator EndItr); // 返回ResourceTracker。 DFAPacketizer *getResourceTracker() {return ResourceTracker;} // 添加指令到当前包。 virtual MachineBasicBlock::iterator addToPacket(MachineInstr \u0026MI) { CurrentPacketMIs.push_back(\u0026MI); ResourceTracker-\u003ereserveResources(MI); return MI; } // 结束当前打包并且重置打包器的状态。 // 覆盖当前函数允许确切目标打包器执行自定义最终处理。 virtual void endPacket(MachineBasicBlock *MBB, MachineBasicBlock::iterator MI); // 在将指令打包之前执行初始化。该函数应由依赖于目标的打包器覆盖。 virtual void initPacketizerState() {} // 检查是否给定的指令应当被打包器忽视。 virtual bool ignorePseudoInstruction(const MachineInstr \u0026I, const MachineBasicBlock *MBB) { return false; } // 若当前指令不能和任意一个指令打包，则返回true，这意味着当前指令独自为一个包。 virtual bool isSoloInstruction(const MachineInstr \u0026MI) { return true; } // 检查打包器是否应该尝试将给定的指令添加到当前数据包中。 // 可能不希望将指令包含在当前数据包中的原因之一是，它可能导致停滞。 // 如果这个函数返回 \"false\"，则当前数据包将结束，并且该指令将被添加到下一个数据包中。 virtual bool shouldAddToPacket(const MachineInstr \u0026MI) { return true; } // 检查将 SUI 和 SUJ 打包在一起是否合法。 virtual bool isLegalToPacketizeTogether(SUnit *SUI, SUnit *SUJ) { return false; } // 检查在 SUI 和 SUJ 之间剪枝是否合法。 virtual bool isLegalToPruneDependencies(SUnit *SUI, SUnit *SUJ) { return false; } // 在打包开始前，增加一次 DAG 突变。 void addMutation(std::unique_ptr\u003cScheduleDAGMutation\u003e Mutation); bool alias(const MachineInstr \u0026MI1, const MachineInstr \u0026MI2, bool UseTBAA = true) const; private: bool alias(const MachineMemOperand \u0026Op1, const MachineMemOperand \u0026Op2, bool UseTBAA = true) const; }; ","date":"2024-09-03","objectID":"/dfa_packetizer/:3:1","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"变量 MF MachineFunction \u0026MF TII 目标指令信息。 const TargetInstrInfo *TII AA 别名分析。 AAResults *AA VLIWScheduler VLIW调度器。 DefaultVLIWScheduler *VLIWScheduler CurrentPacketMIs 当前数据包包含的指令 std::vector\u003cMachineInstr*\u003e CurrentPacketMIs ResourceTracker DFA资源追踪器。 DFAPacketizer *ResourceTracker MIToSUnit 指令到功能单元的映射关系。 std::map\u003cMachineInstr*, SUnit*\u003e MIToSUnit ","date":"2024-09-03","objectID":"/dfa_packetizer/:3:2","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"目标无关函数 VLIWPacketizerList 构造函数，AAResults参数可以为空指针。 PacketizeMIs 指令打包接口。 void VLIWPacketizerList::PacketizeMIs(MachineBasicBlock *MBB, MachineBasicBlock::iterator BeginItr, MachineBasicBlock::iterator EndItr) { assert(VLIWScheduler \u0026\u0026 \"VLIW Scheduler is not initialized!\"); // 准备调度执行。 VLIWScheduler-\u003estartBlock(MBB); // 为新调度区域初始化 DAG 和通用调度器状态。 // 这实际上并不创建 DAG，只是清除它。 // 调度驱动程序可在每个调度区域多次调用 BuildSchedGraph。 VLIWScheduler-\u003eenterRegion(MBB, BeginItr, EndItr, std::distance(BeginItr, EndItr)); VLIWScheduler-\u003eschedule(); LLVM_DEBUG({ dbgs() \u003c\u003c \"Scheduling DAG of the packetize region\\n\"; VLIWScheduler-\u003edump(); }); // 生成机器指令到调度单元的映射。 MIToSUnit.clear(); for (SUnit \u0026SU : VLIWScheduler-\u003eSUnits) MIToSUnit[SU.getInstr()] = \u0026SU; bool LimitPresent = InstrLimit.getPosition(); // 打包。 for (; BeginItr != EndItr; ++BeginItr) { if (LimitPresent) { if (InstrCount \u003e= InstrLimit) { EndItr = BeginItr; break; } InstrCount++; } MachineInstr \u0026MI = *BeginItr; initPacketizerState(); // 如果需要结束当前打包。 if (isSoloInstruction(MI)) { endPacket(MBB, MI); continue; } // 忽视伪指令。 if (ignorePseudoInstruction(MI, MBB)) continue; SUnit *SUI = MIToSUnit[\u0026MI]; assert(SUI \u0026\u0026 \"Missing SUnit Info!\"); // 询问DFA该机器指令所需资源是否可获取。 LLVM_DEBUG(dbgs() \u003c\u003c \"Checking resources for adding MI to packet \" \u003c\u003c MI); bool ResourceAvail = ResourceTracker-\u003ecanReserveResources(MI); LLVM_DEBUG({ if (ResourceAvail) dbgs() \u003c\u003c \" Resources are available for adding MI to packet\\n\"; else dbgs() \u003c\u003c \" Resources NOT available\\n\"; }); if (ResourceAvail \u0026\u0026 shouldAddToPacket(MI)) { // 检查当前指令和包中指令依赖关系。 for (auto *MJ : CurrentPacketMIs) { SUnit *SUJ = MIToSUnit[MJ]; assert(SUJ \u0026\u0026 \"Missing SUnit Info!\"); LLVM_DEBUG(dbgs() \u003c\u003c \" Checking against MJ \" \u003c\u003c *MJ); // 打包SUI和SUJ是否合法。 if (!isLegalToPacketizeTogether(SUI, SUJ)) { LLVM_DEBUG(dbgs() \u003c\u003c \" Not legal to add MI, try to prune\\n\"); // 如果依赖可以被剪枝则打包。 if (!isLegalToPruneDependencies(SUI, SUJ)) { // 如果依赖不能剪枝则结束打包。 LLVM_DEBUG(dbgs() \u003c\u003c \" Could not prune dependencies for adding MI\\n\"); endPacket(MBB, MI); break; } LLVM_DEBUG(dbgs() \u003c\u003c \" Pruned dependence for adding MI\\n\"); } } } else { LLVM_DEBUG(if (ResourceAvail) dbgs() \u003c\u003c \"Resources are available, but instruction should not be \" \"added to packet\\n \" \u003c\u003c MI); // 如果资源不可获取或指令不能加入当前包则结束打包。 endPacket(MBB, MI); } // 添加MI到当前包。 LLVM_DEBUG(dbgs() \u003c\u003c \"* Adding MI to packet \" \u003c\u003c MI \u003c\u003c '\\n'); BeginItr = addToPacket(MI); } // 对于打包范围的所有指令。 // 结束任何遗留的数据包。 endPacket(MBB, EndItr); VLIWScheduler-\u003eexitRegion(); VLIWScheduler-\u003efinishBlock(); } getResourceTracker 返回ResourceTracker。 addMutation 在打包开始前，增加一次 DAG 突变。 alias public alias private ","date":"2024-09-03","objectID":"/dfa_packetizer/:3:3","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"目标相关函数 ~VLIWPacketizerList() 析构函数 addToPacket 添加指令到当前包。（存在默认实现） #Todo endPacket 结束当前打包并且重置打包器的状态，覆盖当前函数允许确切目标打包器执行自定义最终处理。（存在默认实现） #Todo initPacketizerState 在将指令打包之前执行初始化。该函数应由依赖于目标的打包器覆盖。 #Todo ignorePseudoInstruction 检查是否给定的指令应当被打包器忽视。 #Todo isSoloInstruction 若当前指令不能和任意一个指令打包，则返回true，这意味着当前指令独自为一个包。 #Todo shouldAddToPacket 检查打包器是否应该尝试将给定的指令添加到当前数据包中。 可能不希望将指令包含在当前数据包中的原因之一是，它可能导致停滞。 如果这个函数返回 “false”，则当前数据包将结束，并且该指令将被添加到下一个数据包中。 #Todo isLegalToPacketizeTogether 检查将 SUI 和 SUJ 打包在一起是否合法。 #Todo isLegalToPruneDependencies 检查剪枝 SUI 和 SUJ 之间的依赖是否合法。 #Todo ","date":"2024-09-03","objectID":"/dfa_packetizer/:3:4","tags":["note","llvm-backend"],"title":"DFA Packetizer","uri":"/dfa_packetizer/"},{"categories":["LLVM"],"content":"SMS： Swing Modulo Scheduling (SMS， 摇摆模调度) 是一种软件流水线技术，它旨在通过重叠循环的不同迭代指令来提高指令级并行性（ILP），从而优化循环的执行性能。SMS 特别关注于降低寄存器压力，同时在合理的编译时间内生成高效的调度序列 1。它属于模调度算法的一种，模调度算法尝试重叠单基本块循环的迭代，并根据一组启发式规则得出的优先级来调度指令。 目标文件：llvm/lib/CodeGen/MachinePipeliner.cpp Pass执行：在寄存器分配Pass前。 概念 含义 MII(minimal initiation interval) 指完成循环所需的最小间隔，MII=max(RecMII,ResMII)。 ResMII(Resource MII) 根据一次循环所需的功能单元(FU, function unit)去除以机器所有功能单元的结果。如果循环中包含多类FU的使用(且每类FU之间相互无法替换)，则ResMII是分别对每一类FU计算ResMII后的最大值。 RecMII(Recurrence MII) 循环中环路完成一次迭代所需的最小间隔，如果循环存在多条数据链路则分别计算后取其最大值。 软件流水循环执行模型： ","date":"2024-07-30","objectID":"/software_pipeliner/:0:0","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"SMS算法 ","date":"2024-07-30","objectID":"/software_pipeliner/:1:0","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"依赖图的计算和分析 依赖图包含四个部分： 属性 含义 V 依赖图顶点的集合，其中每个顶点v表示循环中的一个操作。 E 依赖图边的集合，表示依赖关系，SMS中仅存在数据依赖，(u,v)表示v依赖于u。 $δ_(u,v)$ 距离函数。 $λ_u$ 延迟函数，表示相应操作（顶点）所花费的周期数。 附加函数： 属性 含义 ASAP (As Soon As Possible) 指令可以开始执行的最早时间点。 ALAP (As Late As Possible) 指令可以开始执行的最晚时间点。 MOB(Mobility) MOV (Movement) 节点在调度中的移动量，是从ASAP到当前调度时间的差值，ALAP-ASAP。 D (Depth) 表示按延迟加权的节点的深度。 H (Height) 表示按延迟加权的节点的高度。 ","date":"2024-07-30","objectID":"/software_pipeliner/:1:1","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"节点排序 两种情况： 无循环：自下而上遍历。 有循环：根据每个循环的RecMII的值，从高到低进行处理，遍历方式视情况而定。 排序过程： 计算部分排序/偏序（partial order），将节点分组为有序的集合列表：这些集合按优先级（RecMII值确定）从最高到最低的顺序排列，但每个集合内部没有任何顺序。图的每个节点只属于一个集合。 排序：按部分排序/偏序的优先级遍历每个节点集。 确定该节点集的遍历方式（top-down/bottom-up）。 根据遍历方式对节点进行遍历。 最终输出包含图中所有节点的有序列表O。 ","date":"2024-07-30","objectID":"/software_pipeliner/:1:2","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"节点调度 属性 含义 $v$ 前驱或后继操作节点。 $u$ 当前操作节点。 $t_v$ v已被调度的周期。 $λ_v$ v的延迟。 $δ_(v,u)$ v到u的依赖距离。 $PSP(u)$ previously scheduled predecessors，u已经被调度的前驱节点。 $PSS(u)$ previously scheduled successors，u已经被调度的后继节点。 如果在部分调度（partial schedule）中操作u仅有前驱节点，则尽可能早调度，计算开始时间EarlyStart，从EarlyStart开始扫描直到EarlyStart+II-1寻找空闲延迟槽。 $EarlyStart = max_(v∈PSP(u))(t_v+λ_v-δ_(v,u)×II)$ 如果在部分调度（partial schedule）中操作u仅有后继节点，则尽可能晚调度，计算开始时间LateStart，从LateStart开始扫描直到LateStart+II-1寻找空闲延迟槽。 $LateStart = min_(v∈PSS(u))(t_v+λ_v-δ_(u,v)×II)$ 如果在部分调度（partial schedule）中操作u既有前驱节点又有后继节点，计算EarlyStart和LateStart，从EarlyStart开始扫描直到min(LateStart, EarlyStart + II - 1)寻找空闲延迟槽。 如果在部分调度（partial schedule）中操作u既无前驱节点又无后继节点，则其EarlyStart=ASAP，从EarlyStart开始扫描直到EarlyStart+II-1寻找空闲延迟槽。 ","date":"2024-07-30","objectID":"/software_pipeliner/:1:3","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"无循环示例 MII = 4 依赖图示例： 各节点属性： 排序： R = {n12} bottom-up：O = \u003cn12, n11, n10, n8, n5, n6, n1, n2, n9\u003e top-down：O = \u003cn12, n11, n10, n8, n5, n6, n1, n2, n9, n3, n4, n7\u003e 调度： ","date":"2024-07-30","objectID":"/software_pipeliner/:1:4","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"有循环示例 四个通用功能单元、每个操作延迟为2。 MII = 6 依赖图示例： 排序： 节点分组为有序集 S1 = {A, C, D, F}：第一个循环，$RecMII = (3 nodes × 2 cycles)/(1 distance) = 6$。 S2 = {G, J, M, I}：第二个循环，$RecMII = (3 nodes × 2 cycles)/(2 distance) = 3$。 S3 = {B, E, H, K, L}：剩余节点。 排序 S1：bottom-up：O = \u003cF, C, D, A\u003e S2：top-down：O = \u003cF, C, D, A, G, I, J, M\u003e S3：bottom-up：O = \u003cF, C, D, A, G, I, J, M, H, E, B\u003e S3：top-down：O = \u003cF, C, D, A, G, I, J, M, H, E, B, L, K\u003e 调度： ","date":"2024-07-30","objectID":"/software_pipeliner/:1:5","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"llvm软流水实现流程 使用ScheduleDAGInstrs类，通过DAG结构表示依赖关系，使用指向 Phi 节点的顺序边表示循环相关性。 使用DFAPacketizer类，消除DAG中不必要的边，计算最小启动间隔，并检查在流水线计划中可以插入指令的位置。 计算出最小初始间隔(MII, minimal initiation interval)。 建立dependence graph, 计算每条指令的相关信息(ASAP ALAP MOV Height Depth …)。 节点排序。 ","date":"2024-07-30","objectID":"/software_pipeliner/:2:0","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"llvm软流水具体实现 bool MachinePipeliner::scheduleLoop(MachineLoop \u0026L)在确切的循环上执行SMS算法，该函数识别候选循环，计算最小启动间隔，并尝试调度循环。 ","date":"2024-07-30","objectID":"/software_pipeliner/:3:0","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"llvm软流水相关符号 ","date":"2024-07-30","objectID":"/software_pipeliner/:4:0","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"dependence graph SU: Scheduling unit，调度单元 # preds left: 当前调度单元剩余的前驱（predecessors）数量。 # succs left: 当前调度单元剩余的后继（successors）数量。 # rdefs left: 表示当前调度单元剩余的寄存器定义（register definitions）数量。 Latency: 表示执行当前操作的延迟。 Depth: 表示当前节点在控制流图中的深度。 Height: 表示当前节点在控制流图中的高度。 Successors: 列出了当前节点的后继节点。 SU(x): Data Latency=0 Reg=%y: 表示到编号为x的后继调度单元的数据延迟是0，即使用寄存器%y的值没有延迟。 SU(x): Anti Latency=1: 表示到编号为x的后继调度单元的反依赖（anti-dependence）延迟是1。反依赖通常发生在循环中，当一个指令的执行结果需要在某个时间点之前被另一个指令使用时。这里的“1”表示在当前节点和使用该结果的指令之间有一个周期的延迟。 ","date":"2024-07-30","objectID":"/software_pipeliner/:4:1","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"Node 属性 含义 ASAP (As Soon As Possible) 指令可以开始执行的最早时间点。 ALAP (As Late As Possible) 指令可以开始执行的最晚时间点。 MOV (Movement) 节点在调度中的移动量，是从ASAP到当前调度时间的差值，ALAP-ASAP。 D (Depth) 表示按延迟加权的节点的深度。 H (Height) 表示按延迟加权的节点的高度。 ZLD (Zero Latency Depth) 表示在没有考虑指令延迟的情况下，节点的深度。 ZLH (Zero Latency Height) 表示在没有考虑指令延迟的情况下，节点的高度。 ","date":"2024-07-30","objectID":"/software_pipeliner/:4:2","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"NodeSet 属性 含义 Num nodes 当前节点集包含的节点数。 rec RecMII。 mov MaxMOV，节点在调度中的移动量。 depth MaxDepth。 col Colocate，定位。 ","date":"2024-07-30","objectID":"/software_pipeliner/:4:3","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"参考 1. Lifetime-Sensitive Modulo Scheduling in a Production Environment ","date":"2024-07-30","objectID":"/software_pipeliner/:5:0","tags":["note","llvm-backend"],"title":"Software Pipeliner","uri":"/software_pipeliner/"},{"categories":["LLVM"],"content":"The LLVM Target-Independent Code Generator — LLVM 15.0.0 documentation 是一个提供一套可复用的组件的框架，将LLVM内部表示以汇编形式（静态编译器）、二进制（JIT编译器）翻译成特定平台的机器码 ·抽象目标描述接口 in include/llvm/Target/ ·用于表示为目标生成的代码的类。这些类旨在足够抽象，以表示任何目标机器的机器代码 in include/llvm/CodeGen/ ·用于在目标文档级别（MC层）表示代码的类和算法。这些类表示汇编级构造，如标签、节和指令 ·目标无关的算法，用于实现本机代码生成的各个阶段（寄存器分配、调度、堆栈帧表示等） in lib/CodeGen/ ·特定目标的抽象目标描述接口的实现。这些机器描述利用 LLVM 提供的组件，并可以选择提供特定于目标的自定义pass，为特定目标构建完整的代码生成器 in lib/Target/ ·目标无关的JIT组件 in lib/ExecutionEngine/JIT ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:0:0","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"Target description classes 独立于任何客户端的目标机器的抽象描述 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:1:0","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"TargetMachine 目标描述类的实现，需要继承 提供get*Info虚拟方法去访问目标描述类 getInstrInfo getRegisterInfo getFrameInfo … ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:1:1","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"DataLayout 数据布局，唯一且必需，不能派生 内存结构、数据类型对齐方式、指针大小、大端序或小端序 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:1:2","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"TargetLowering 如何将LLVM Code降为SelectionDAG操作 定义： ·目标机器所支持操作 ·用于位移数量的类型 ·setcc操作的返回类型 ·高级特征，比如是否将除法变为乘法序列 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:1:3","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"TargetRegisterInfo 寄存器描述、寄存器和寄存器之间的交互 虚拟寄存器：无符号整型，大数字 物理寄存器：唯一小数字 寄存器#0表示标志值 每个寄存器有一个相关联的TargetRegisterDesc，表明寄存器名称和别名 该类公开一组特定处理器的寄存器类，每一个寄存器类包含了一组寄存器，他们有相同的属性。每一个由指令选择器创建的SSA虚拟寄存器都和一个寄存器类相关，当寄存器分配器运行时，会将这些虚拟寄存器以物理寄存器进行代替。==这些寄存器类的实现是由tablegen文件自动生成的== ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:1:4","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"TargetInstrInfo 描述目标支持的机器指令 ·操作码的助记符 ·操作数的数量 ·隐式寄存器的使用和定义列表 ·指令是否有与目标无关的属性（访问内存、可互交换等） ·任何特定于目标的标志 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:1:5","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"TargetFrameLowering 目标堆栈结构的布局 保存堆栈增长的方向、进入每个函数时的已知堆栈对齐以及局部区域的偏移量，局部区域的偏移量是从函数入口上的堆栈指针到可以存储函数数据（局部变量、溢出位置）的第一个位置的偏移量 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:1:6","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"TargetSubTarget 目标芯片组信息 子目标通知代码生成支持哪些指令、指令延迟和指令执行路线;即，使用哪些处理单元、以什么顺序以及使用多长时间 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:1:7","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"TargetJITInfo 提供一个抽象接口，该接口使用JIT（Just-In-Time及时）代码生成去执行目标确切的活动 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:1:8","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"Machine code description classes 在高级别，LLVM代码被转换为由MachineFunction，MachineBasicBlock和MachineInstr实例组成的机器特定表示，这个表示完全与目标无关，它以一种抽象形式：一个操作码和一系列操作数表示指令 这种表示旨在支持机器码的SSA表示、寄存器分配、非SSA形式 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:2:0","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"MachineInstr 目标机器的指令表示为MachineInstr类的实例，此类只跟踪一个操作码和一组操作数 操作码是一个简单的无符号整型，仅仅对特定后端有意义 一个目标后端的指令定义在*InstrInfo.td中，操作码的枚举值是根据此文件自动生成的，MachineInstr类没有关于怎样解释指令的信息，需要参考TargetInstrInfo类 机器指令的操作数可以是几种不同的类型：寄存器引用、常量整数、基本块引用等。机器操作数应标记为def或值的使用（尽管只允许寄存器为defs） 按照惯例，LLVM代码生成器对指令操作数进行排序，以便所有寄存器定义都出现在寄存器使用之前，即使在通常以其他顺序打印的体系结构上也是如此。例如，SPARC 添加指令：“add %i1， %i2， %i3”，“%i1”，“%i2” 寄存器值相加并将结果存储到 “%i3” 寄存器中。在 LLVM 代码生成器中，操作数应存储为 “%i3， %i1， %i2”：目标在第一位。这样方便调试输出以及创建仅仅def第一个操作数的指令 MachineInstrBuilder.h BuildMI：便于创建任意机器指令，MachineInstruction // Create a 'DestReg = mov 42' (rendered in X86 assembly as 'mov DestReg, 42') // instruction and insert it at the end of the given MachineBasicBlock. const TargetInstrInfo \u0026TII = ... MachineBasicBlock \u0026MBB = ... DebugLoc DL; MachineInstr *MI = BuildMI(MBB, DL, TII.get(X86::MOV32ri), DestReg).addImm(42); // Create the same instr, but insert it before a specified iterator point. MachineBasicBlock::iterator MBBI = ... BuildMI(MBB, MBBI, DL, TII.get(X86::MOV32ri), DestReg).addImm(42); // Create a 'cmp Reg, 0' instruction, no destination reg. MI = BuildMI(MBB, DL, TII.get(X86::CMP32ri8)).addReg(Reg).addImm(42); // Create an 'sahf' instruction which takes no operands and stores nothing. MI = BuildMI(MBB, DL, TII.get(X86::SAHF)); // Create a self looping branch instruction. BuildMI(MBB, DL, TII.get(X86::JNE)).addMBB(\u0026MBB); Fixed（preassigned） register 固定寄存器 EAX、EBX … Call-clobbered registers 调用、中断寄存器 相较于每次添加\u003cdef,dead\u003e操作数，不如只使用一个MO_RegisterMask操作数代替，寄存器掩码操作数包含保留寄存器的位掩码，其他所有内容都被视为被指令破坏 Machine code in SSA form MachineInstr最初以SSA形式选择，并以SSA形式维护，直到发生寄存器分配。在大多数情况下，这非常简单，因为 LLVM 已经是 SSA 形式；LLVM PHI 节点成为机器码 PHI 节点，虚拟寄存器只允许有一个定义 寄存器分配后，机器代码不再是 SSA 形式，因为代码中没有剩余的虚拟寄存器。 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:2:1","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"MachineBasicBlock 该类包含一个机器指令的列表（==MachineInstr实例==），它大致对应于指令选择器的LLVM代码输入，但可以有一对多映射（即一个LLVM基本块可以映射到多个机器基本块） 包含getBasicBlock方法，返回来自的LLVM基本块 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:2:2","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"MachineFunction include/llvm/CodeGen/MachineFunction.h 该类包含一个机器基础块的列表（==MachineBasicBlock的实例==），它和指令选择器的LLVM函数输入一一对应 除此之外，该类包含一个 MachineConstantPool, 一个 MachineFrameInfo, 一个 MachineFunctionInfo, 和一个 MachineRegisterInfo ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:2:3","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"MachineInstr Bundles #obscure -------------- | Bundle | --------- -------------- \\ | ---------------- | | MI | | ---------------- | | | ---------------- | | MI | | ---------------- | | | ---------------- | | MI | | ---------------- | -------------- | Bundle | -------- -------------- \\ | ---------------- | | MI | | ---------------- | | | ---------------- | | MI | | ---------------- | | | ... | -------------- | Bundle | -------- -------------- \\ | ... MachineInstr passes应该作为单个单元在MI bundle上操作 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:2:4","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"MC Layer MC 层用于在原始机器代码级别表示和处理代码，没有“高级”信息，如“常量池”、“跳转表”、“全局变量”或类似的东西。 这一层中的代码用于许多重要目的：代码生成器的尾端使用它来编写.s或.o文档，并且LLVM-mc工具也使用它来实现独立的机器代码汇编器和反汇编器。 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:3:0","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"MCStreamer #obscure 将LLVM IR转换为目标机器码（机器指令） 它是一个抽象的API，以不同的方式实现（例如，输出.s文档，输出ELF .o文档等），但其API直接对应于在.s文档中看到的内容。 MCStreamer每个指令都有一个方法，如EmitLabel，EmitSymbolAttribute，switchSection，emitValue（用于.byte，.word）等，直接对应于汇编级指令。它也有一个EmitInstruction方法，输出一个MCInst到流中 两种实现： ·输出.s文件（MCAsmStreamer） ·输出.o文件（MCObjectStreamer） MCAsmStreamer是一个简单的实现，它为每个方法打印出一个指令（例如EmitValue -\u003e .byte），但MCObjectStreamer实现了完整的汇编进程。 对于目标确切的指令，MCStreamer有一个MCTargetStreamer实例，每一个需要它的目标定义了一个继承它的类，每个指令包含一个方法两个继承它的类，分别是target object streamer 和 target asm streamer。target asm streamer只打印它（emitFnStart -\u003e .fnstart），target object streamer为它实现汇编逻辑。 为了使llvm调用这些类，目标必须调用TargetRegistry::RegisterAsmStreamer 和 TargetRegistry::RegisterMCObjectStreamer传递回调，这些回调分配相应的目标流并将其传递给 createAsmStreamer 或相应的对象流构造函数。 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:3:1","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"MCContext MCContext 类是 MC 层各种唯一数据结构的所有者。 因此，这是可以与之交互以创建symbols和sections的类。此类不能被子类化。 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:3:2","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"MCSymbol 在汇编文件中表示一个标签 ·汇编临时标签 被汇编器使用但会在目标文件生成时丢弃 ·普通标签 两种的区别通常通过在标签中添加前缀来表示，例如“L”标签是MachO中的汇编临时标签。 MCSymbols由MCContext创建并且是唯一的，可以通过比较指针的等价性来判断是否为相同的symbol，指针不等不能保证标签最终会位于不同地址 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:3:3","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"MCSection 代表目标文件确切的section 被目标文件进行子类化来实现（MCSectionMachO, MCSectionCOFF, MCSectionELF），由由MCContext创建并且是唯一的 MCStreamer具有当前部分的概念，可以使用SwitchToSection方法（对应于.s文档中的“.section”指令）进行更改。 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:3:4","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"MCInst 是机器指令的目标无关表示（MC层） 比MachineInstr更简单的类，包含明确目标的操作码和MC操作数向量 是指令编码器、指令输出使用的类型，以及汇编解析器和反汇编器生成的类型。 MCOperand有三种情况： 1）一个简单的立即数 2）目标寄存器ID 3）作为MCExpr的符号表达式（例如“Lfoo-Lbar+42”） ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:3:5","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"Object File Format Format Supported Targets COFF AArch64, ARM, X86 DXContainer DirectX ELF AArch64, AMDGPU, ARM, AVR, BPF, CSKY, Hexagon, Lanai, LoongArch, M86k, MSP430, MIPS, PowerPC, RISCV, SPARC, SystemZ, VE, X86 GCOFF SystemZ MachO AArch64, ARM, X86 SPIR-V SPIRV WASM WebAssembly XCOFF PowerPC ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:3:6","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"Target-independent code generation algorithms 描述代码生成的高级设计，解释如何工作以及设计背后的逻辑合理性 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:4:0","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"Instruction Selection 将呈现给代码生成器的LLVM code转化为目标确切机器指令 DAG指令选择器是从目标描述（.td）文件中生成的 SelectionDAG 操作节点类型描述 in include/llvm/CodeGen/ISDOpcodes.h SelectionDAG Instruction Selection Process 每次合法化之后需要优化，主要优化插入标志和零扩展指令 Build initial DAG 将LLVM code输入转化为非法的SelectionDAG 此pass的目的是向 SelectionDAG 公开尽可能多的低级别、特定于目标的详细信息。需要特定于目标的钩子来降低调用、返回、varargs 等 对于这些特征，使用TargetLowering接口 Optimize SelectionDAG 简化：使用简单优化方式简化DAG 识别：识别支持这些元操作的目标上的元指令（例如旋转和除/余数对） 使生成的代码更高效，select instructions from DAG 阶段的选择指令更简单 Legalize SelectionDAG Types 转换SelectionDAG节点以消除任何目标不支持的类型 标量：promoting（小类型提升为大类型）、expanding（大类型分解为小类型） 向量：widening（将向量多次拆分）、scalarizing（标量化） 目标实现通过在其 TargetLower 构造函数中调用 addRegisterClass 方法来告诉合法化进程支持哪些类型（以及用于它们的寄存器类） Optimize SelectionDAG 清理类型合法化带来的冗余 Legalize SelectionDAG Ops 转换SelectionDAG节点以消除任何目标不支持的操作 expansion promotion custom shufflevector向量重排 Optimize SelectionDAG 消除操作合法化带来的低效率 Select instructions from DAG 将目标无关DAG输入转换为特定目标指令的DAG %t1 = fadd float %W, %X %t2 = fmul float %t1, %Y %t3 = fadd float %t2, %Z \u003c--\u003e(fadd:f32 (fmul:f32 (fadd:f32 W, X), Y), Z) 如果目标支持FMADDS，即乘加指令，转换为 --\u003e(FMADDS (FADDS W, X), Y, Z) def FMADDS : AForm_1\u003c59, 29, (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB), \"fmadds $FRT, $FRA, $FRC, $FRB\", [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC), F4RC:$FRB))]\u003e; def FADDS : AForm_2\u003c59, 21, (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRB), \"fadds $FRT, $FRA, $FRB\", [(set F4RC:$FRT, (fadd F4RC:$FRA, F4RC:$FRB))]\u003e; F4RC是输入和结果的寄存器类 DAG操作 in include/llvm/Target/TargetSelectionDAG.td TableGen DAG指令选择生成器读取.td文件中的pattern并自动构建模式匹配代码： ·编译时，分析指令模式是否有意义 ·处理模式匹配的操作数上的任意约束 ·自动类型推断 ·目标可以定义自己的（并依赖于内置的）模式片段 模式片段是可重用的模式的块，在编译时内联到模式中 ·使用Pat类定义pattern对应一个或多个指令 def : Pat\u003c(i32 imm:$imm), (ORI (LIS (HI16 imm:$imm)), (LO16 imm:$imm))\u003e; 将32位立即数放入寄存器中 匹配过程： 接收一个32位立即数 ORI:表示`or`操作 LIS:将16位立即数左移16位 HI16和LO16拿取32位立即数的高16和低16位 SelectionDAG Scheduling and Formation 为目标指令DAG中的指令分配一个线性顺序并发送其到正在编译的MachineFunction中 从选择阶段得到目标指令的DAG并分配顺序，当排好序后将DAG转化为一个MachineInstr列表 完成所有这些步骤后，将销毁 SelectionDAG 并运行其余代码生成过程 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:4:1","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"SSA-based Machine Code Optimizations ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:4:2","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"Live Intervals 活动时期 在寄存器分配pass中决定是否需要同一个物理寄存器的两个或更多的虚拟寄存器在程序中的同一点处于活动状态，如果存在，将一个寄存器溢出 Live Variable Analysis #obscure Live Intervals Analysis #obscure ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:4:3","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"Register Allocation 虚拟寄存器无限，物理寄存器有限。 如果物理寄存器不能适应所有虚拟寄存器，则将部分映射到内存中，被称为溢出虚拟对象 Registers represent in LLVM 物理寄存器：1-1023 in GenRegisterNames.inc 物理寄存器别名：RegisterInfo.td MCRegAliasIterator LLVM 中的物理寄存器按寄存器类分组。同一寄存器类中的元素在功能上是等效的，并且可以互换使用 不同物理寄存器可能使用相同编号 静态定义在TargetRegisterInfo.td中 不同虚拟寄存器不会使用相同编号 使用MachineRegisterInfo::createVirtualRegister()创建新的虚拟寄存器 MachineOperand::isRegister()：是否是寄存器 MachineOperand::getReg()：得到寄存器编号 MachineOperand::isUse()：是否被指令使用 MachineOperand::isDef()：是否定义 我们将在寄存器分配之前LLVM位码中存在的物理寄存器称为预着色寄存器（Pre-colored） ·传递函数调用参数 ·存储特殊指令结果 分为： ·隐式定义：静态定义在每个指令 ·显式定义：依赖被编译的程序 预着色寄存器对任何寄存器分配算法施加约束。寄存器分配器必须确保它们都不会在虚拟寄存器处于活动状态时被虚拟寄存器的值覆盖。 Mapping virtual registers to physical registers ·direct mapping 使用TargetRegisterInfo和MachineOperand类 利于寄存器分配的开发人员，但更容易出错，并需要大量工作实现。 程序员必须指定在正在编译的目标函数中应插入加载和存储指令的位置，以便在内存中获取和存储值。 要将物理寄存器分配给给定操作数中存在的虚拟寄存器，使用 MachineOperand：：setReg（p_reg）。要插入存储指令，使用 TargetInstrInfo：：storeRegToStackSlot（…），要插入加载指令，使用 TargetInstrInfo：：loadRegFromStackSlot。 ·indirect mapping 使用VirtRegMap类，插入加载和存储向内存发送和从内存获取值。 间接映射使应用程序开发人员免受插入加载和存储指令的复杂性的影响。 为了将虚拟寄存器映射到物理寄存器，使用 VirtRegMap::assignVirt2Phys(vreg, preg)。为了将某个虚拟寄存器映射到内存，使用 VirtRegMap::assignVirt2StackSlot(vreg) Handling two address instructions 大多数LLVM机器码指令是三地址指令，即至多定义一个寄存器，至少使用两个寄存器 少部分结构使用二地址指令，则被定义的寄存器即被定义也被使用 将代表二地址指令的三地址指令转化为二地址指令：TwoAddressInstructionPass，其在寄存器分配前执行并替代三地址指令。但是执行后的指令不符合SSA形式 %a = ADD %b %c ↓ %a = MOVE %b %a = ADD %a %c The SSA deconstruction phase 是寄存器分配阶段的重要转换 SSA形式简化了对程序控制流图执行的许多分析，但是传统指令集不能实现PHI（是SSA的）指令，为了生成可执行代码，编译器必须将PHI指令替换为其他可保留语义的指令 ·最传统的 PHI 解构算法用复制指令取代 PHI 指令，in lib/CodeGen/PHIElimination.cpp。 需要在寄存器分配器中标记PHIEliminationID标识符 Instruction folding 一种在寄存器分配阶段移除不必要的复制指令的优化 %EBX = LOAD %mem_address %EAX = COPY %EBX %EAX = LOAD %mem_address 使用TargetRegisterInfo::foldMemoryOperand(...)方法折叠指令，一个指令折叠前后有很大差异 在lib/CodeGen/LiveIntervalAnalysis.cpp的LiveIntervals::addIntervalsForSpills中有相关例子 Built in register allocators LLVM提供了三种寄存器分配器： ·Fast 调试建立默认分配器，在基础块级别，保留寄存器值并尽可能重复利用寄存器 ·Basic 实时范围按启发式驱动的顺序一次分配给一个寄存器 ·Greedy 默认分配器，此分配器努力将溢出代码的成本降至最低。 ·PBQP Partitioned Boolean Quadratic Programming 分段布尔二次规划 此分配器的工作原理是构造一个表示所考虑的寄存器分配问题的 PBQP 问题，使用 PBQP 求解器解决此问题，然后将解决方案映射回寄存器分配。 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:4:4","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"Prolog/Epilog Code Insertion ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:4:5","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"Compact Unwind 抛出异常需要展开一个函数，怎样展开给定函数的信息通常使用DWARF表示，但是每个函数每一个FDE需要20~30字节 DWARF：Debugging With Attributed Record Formats FDE：Frame Description Entry 帧描述条目 compact unwind每一个函数只需要4字节表示-32bit 它指定要恢复哪些寄存器以及从何处恢复，以及展开函数。 当链接时，会创建一个__TEXT,__unwind_info部分，这个section轻量并且能很快运行去获取函数展开信息。 如果使用compact unwind，会将其编码到__TEXT,__unwind_info 如果使用DWARF unwind，在链接时__TEXT,__unwind_info会包含__TEXT,__eh_frame，其中包含了FDE的偏移量 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:4:6","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"Late Machine Code Optimizations ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:4:7","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"Code Emission 代码生成的代码发射步骤负责从代码生成器抽象（如MachineFunction，MachineInstr等）降低到MC层使用的抽象（MCInst，MCStreamer等），这是由多种类结合完成的：与目标无关的 AsmPrinter 类、AsmPrinter 的目标特定子类（如 SparcAsmPrinter）和 TargetLoweringObjectFile 类。 MC layers在目标文件的抽象级别工作，它没有函数、全局变量等的概念。它考虑的是标签、命令、指令。此时使用的关键类是MCStreamer，这是一个抽象的API，以不同的方式实现（例如输出.s文档，输出ELF .o文档等），实际上是一个“汇编进程API” 为Target实现code generator： ·为目标定义AsmPrinter的子类 ·为目标实现指令打印器，指令打印器将一个MCInst作为文本发送到raw_osream，多数是由.td文件自动生成的 ·实现MachineInstr到MCInst的代码 in \u003ctarget\u003eMCInstLower.cpp，负责将跳转表条目、常量池索引、全局变量地址等转换为MCLabels，也负责将代码生成器使用的伪操作扩展为相对应的实际机器指令。由此产生的MCInst被送入指令打印器或编码器。 可以实现一个MCCodeEmitter的子类将MCInst降低为机器代码字节并重定位 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:4:8","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["LLVM"],"content":"VLIW Packetizer Very Long Instruction Word 在超长指令字 （VLIW） 体系结构中，编译器负责将指令映射到体系结构上可用的功能单元。为此，编译器创建称为数据包或捆绑包的指令组。LLVM 中的 VLIW 数据包器是一种独立于目标的机制，用于启用机器指令的数据包化。 Mapping from instructions to functional units VLIW目标可以被映射为多个函数单元 在数据打包过程中，需要确定指令是否可以放入包中，通过检查所有可能映射来确定，相对复杂。VLIW Packetizer在编译器build时通过解析目标指令类并生成表格来降低复杂度，可以通过提供的机器无关API去询问这些表格来决定是否指令可以容纳到包中 How the packetization tables are generated and used packetizer从目标Itinerary中读取指令类并创建DFA DFA：deterministic finite automaton 确定有限自动机 ·inputs：表示要添加到包中的指令 ·states：表示包中的指令可能消耗的函数单元 ·transitions：添加指令到已存在的包，如果指令到函数单元映射合法，则会出现相对应的transition，没有transition表示不存在合法映射并且指令不能被添加到包中 要为 VLIW 目标生成表，将 TargetGenDFAPacketizer.inc 作为目标添加到目标目录中的Makefile中。导出的 API 提供三个函数：DFAPacketizer：：clearResources（）、DFAPacketizer：：reserveResources（MachineInstr *MI） 和 DFAPacketizer：：canReserveResources（MachineInstr *MI）。这些函数允许目标数据包化器向现有数据包添加指令，并检查是否可以将指令添加到数据包中。有关更多信息 in llvm/CodeGen/DFAPacketizer.h。 ","date":"2024-07-24","objectID":"/llvm_target_independent_code_generator/:4:9","tags":["note","llvm-backend"],"title":"LLVM Target Independent Code Generator","uri":"/llvm_target_independent_code_generator/"},{"categories":["TOOL"],"content":"CMake-Install CMake/files wget https://cmake.org/files/v3.24/cmake-3.24.0-linux-x86_64.sh sh cmake-3.24.0-linux-x86_64.sh --prefix=/usr/local --exclude-subdir 或 wget https://cmake.org/files/v3.24/cmake-3.24.0-linux-x86_64.tar.gz export PATH=/root/cmake-3.24.0-linux-x86_64/bin:$PATH ","date":"2024-07-23","objectID":"/cmake/:1:0","tags":["basic"],"title":"Cmake","uri":"/cmake/"},{"categories":["TOOL"],"content":"CMake ","date":"2024-07-23","objectID":"/cmake/:2:0","tags":["basic"],"title":"Cmake","uri":"/cmake/"},{"categories":["TOOL"],"content":"config 参数 含义 -S 指定源文件根目录，必须包含一个CMakeLists.txt文件 -B 指定构建目录，构建生成的中间文件和目标文件的生成路径 -D 指定变量，格式为-D \u003cvar\u003e=\u003cvalue\u003e，-D后面的空格可以省略 ","date":"2024-07-23","objectID":"/cmake/:2:1","tags":["basic"],"title":"Cmake","uri":"/cmake/"},{"categories":["TOOL"],"content":"build cmake --build [\u003cdir\u003e | --preset \u003cpreset\u003e] 参数 含义 –target 指定构建目标代替默认的构建目标，可以指定多个 –parallel/-j [\u003cjobs\u003e] 指定构建目标时使用的进程数 ","date":"2024-07-23","objectID":"/cmake/:2:2","tags":["basic"],"title":"Cmake","uri":"/cmake/"},{"categories":["TOOL"],"content":"CMakeLists.txt ","date":"2024-07-23","objectID":"/cmake/:3:0","tags":["basic"],"title":"Cmake","uri":"/cmake/"},{"categories":["TOOL"],"content":"Attribute CMAKE_CURRENT_LIST_FILE 当前正在处理的 CMakeLists.txt 文件的完整路径 结果：/root/Cache-Management-ycy/main-project/CMakeLists.txt ","date":"2024-07-23","objectID":"/cmake/:3:1","tags":["basic"],"title":"Cmake","uri":"/cmake/"},{"categories":["TOOL"],"content":"Operation get_filename_component get_filename_component 函数用于从给定的文件路径中提取特定的部分。 get_filename_component(MLIR_INSTALL_PREFIX \"${CMAKE_CURRENT_LIST_FILE}\" PATH) 获取当前 CMakeLists.txt 文件的目录路径，并将其存储在 MLIR_INSTALL_PREFIX 变量中。 结果：/root/Cache-Management-ycy/main-project add_executable 通过add_executable命令来往构建系统中添加一个可执行构建目标，同样需要指定编译需要的源文件。 add_executable(demo main.cpp) target_link_libraries target_link_libraries命令来声明构建此可执行文件需要链接的库。 target_link_libraries(demo MLIRIR) get_property get_property 函数用于查询并获取全局或局部属性值。 get_property(dialect_libs GLOBAL PROPERTY MLIR_DIALECT_LIBS) pkg_check_modules pkg_check_modules 是 CMake 中的一个宏，用于查询由 pkg-config 管理的库，可以自动找到这些库的编译和链接标志。 指定一个变量名来存储查询结果，以及库的名称。 pkg_check_modules(\u003cvariable\u003e \u003cmodule\u003e [\u003cmodule\u003e...]) pkg_check_modules(PNG libpng) ","date":"2024-07-23","objectID":"/cmake/:3:2","tags":["basic"],"title":"Cmake","uri":"/cmake/"},{"categories":["TOOL"],"content":"CMake-Tools cmake -G Ninja .. -DLLVM_ENABLE_ASSERTIONS=ON -DCMAKE_BUILD_TYPE=RELEASE\\ ","date":"2024-07-23","objectID":"/cmake/:4:0","tags":["basic"],"title":"Cmake","uri":"/cmake/"}]